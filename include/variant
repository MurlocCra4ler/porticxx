#pragma once

#include <cstddef>

namespace std {

template<class... Types>
class my_variant;

namespace impl_variant {

template<typename T> struct is_in_place_type_t : std::false_type {};
template<typename T> struct is_in_place_index_t : std::false_type {};

template<typename U>
struct is_in_place_type_t<std::in_place_type_t<U>> : std::true_type {};

template<size_t I>
struct is_in_place_index_t<std::in_place_index_t<I>> : std::true_type {};

template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
template<class... Ts> overload(Ts...) -> overload<Ts...>;

template<size_t N, typename T>
struct indexed_callable {
    constexpr T operator()(T) const;
};

template<typename... Ts, size_t... Is>
constexpr auto make_overload_impl(std::index_sequence<Is...>) {
    return overload{ indexed_callable<Is, Ts>{}... };
}

template<typename... Ts>
constexpr auto make_overload() {
    return make_overload_impl<Ts...>(std::index_sequence_for<Ts...>{});
}

template<typename T, typename... Types>
struct best_match {
    using overload_t = decltype(make_overload<Types...>());
    using type = decltype(std::declval<overload_t>()(std::declval<T>()));
};

template<typename T>
struct best_match<T> {
    using type = void;
};

template<typename T, typename First, typename... Rest>
constexpr size_t is_unique_helper() {
    if constexpr (sizeof...(Rest) == 0) {
        return std::is_same_v<T, First> ? 1 : 0;
    } else {
        return (std::is_same_v<T, First> ? 1 : 0) + is_unique_helper<T, Rest...>();
    }
}

template<typename T, typename... Types>
static constexpr bool is_unique() {
    return is_unique_helper<T, Types...>() == 1;
}

template<typename T, typename T_j, typename... Types>
concept variant_ctor_constraint =
    (sizeof...(Types) > 0) &&
    (!std::same_as<std::remove_cvref_t<T>, my_variant<Types...>>) &&
    (!is_in_place_type_t<std::remove_cvref_t<T>>::value) &&
    (!is_in_place_index_t<std::remove_cvref_t<T>>::value) &&
    std::is_constructible_v<typename best_match<T, Types...>::type, T> &&
    requires (T&& args) {
        { make_overload<Types...>()(std::forward<T>(args)) };
    };

}

template<class... Types> class variant {
public:
    // constructors
    //constexpr variant() noexcept(/* see description */);
    //constexpr variant(const variant&);
    //constexpr variant(variant&&) noexcept(/* see description */);
 
    template<class T, typename T_j = typename best_match<T, Types...>::type>
    requires variant_ctor_constraint<T, T_j, Types...>
    constexpr variant(T&& args) noexcept(std::is_nothrow_constructible_v<T_j, T>) {
        active_index = index_of<T_j>();
        new (&storage) T_j(std::forward<T>(args));
    }
 
    //template<class T, class... Args>
    //constexpr explicit variant(in_place_type_t<T>, Args&&...);
    //template<class T, class U, class... Args>
    //constexpr explicit variant(in_place_type_t<T>, initializer_list<U>, Args&&...);
 
    //template<size_t I, class... Args>
    //constexpr explicit variant(in_place_index_t<I>, Args&&...);
    //template<size_t I, class U, class... Args>
    //constexpr explicit variant(in_place_index_t<I>, initializer_list<U>, Args&&...);
 
    // destructor
    constexpr ~variant();
 
    // assignment
    constexpr variant& operator=(const variant&);
    //constexpr variant& operator=(variant&&) noexcept(/* see description */);
 
    //template<class T> constexpr variant& operator=(T&&) noexcept(/* see description */);
 
    // modifiers
    template<class T, class... Args> constexpr T& emplace(Args&&...);
    //template<class T, class U, class... Args>
    //constexpr T& emplace(initializer_list<U>, Args&&...);
    //template<size_t I, class... Args>
    //constexpr variant_alternative_t<I, variant<Types...>>& emplace(Args&&...);
    //template<size_t I, class U, class... Args>
    //constexpr variant_alternative_t<I, variant<Types...>>& emplace(initializer_list<U>,
    //                                                               Args&&...);
 
    // value status
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;
 
    // swap
    //constexpr void swap(variant&) noexcept(/* see description */);
 
    // visitation
    template<class Self, class Visitor>
    constexpr decltype(auto) visit(this Self&&, Visitor&&);
    template<class R, class Self, class Visitor>
    constexpr R visit(this Self&&, Visitor&&);

private:
    using this_type = my_variant<Types...>;
    static constexpr std::size_t alignment_value = std::max({alignof(Types)...});

    alignas(alignment_value) char storage[std::max({sizeof(Types)...})];
    size_t active_index;

    template<typename T, typename First, typename... Rest>
    static constexpr std::size_t index_of_helper() {
        if constexpr (std::is_same_v<T, First>) {
            return 0;
        } else if constexpr (sizeof...(Rest) == 0) {
            return static_cast<std::size_t>(-1);  // nicht gefunden
        } else {
            constexpr std::size_t next = index_of_helper<T, Rest...>();
            if constexpr (next == static_cast<std::size_t>(-1)) {
                return static_cast<std::size_t>(-1);
            } else {
                return 1 + next;
            }
        }
    }

    template<typename T>
    requires(is_unique<T, Types...>())
    static constexpr size_t index_of() {
        constexpr size_t index = index_of_helper<T, Types...>();
        static_assert(index > 0, "index not found");
        return index;
    };
};

template<class T, class... Types>
constexpr bool holds_alternative(const std::variant<Types...>& v) noexcept;

//template<size_t I, class... Types>
//constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>&);
//template<size_t I, class... Types>
//constexpr variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&&);
//template<size_t I, class... Types>
//constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>&);
//template<size_t I, class... Types>
//constexpr const variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&&);
 
template<class T, class... Types>
constexpr T& get(variant<Types...>&);               // freestanding-deleted
template<class T, class... Types>
constexpr T&& get(variant<Types...>&&);             // freestanding-deleted
template<class T, class... Types>
constexpr const T& get(const variant<Types...>&);   // freestanding-deleted
template<class T, class... Types>
constexpr const T&& get(const variant<Types...>&&); // freestanding-deleted

}
