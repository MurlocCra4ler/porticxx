#pragma once

#include <cstddef>

namespace std {

template<class... Types> class variant {
public:
    // constructors
    //constexpr variant() noexcept(/* see description */);
    //constexpr variant(const variant&);
    //constexpr variant(variant&&) noexcept(/* see description */);
 
    template<class T> constexpr variant(T&&); //noexcept(/* see description */);
 
    //template<class T, class... Args>
    //constexpr explicit variant(in_place_type_t<T>, Args&&...);
    //template<class T, class U, class... Args>
    //constexpr explicit variant(in_place_type_t<T>, initializer_list<U>, Args&&...);
 
    //template<size_t I, class... Args>
    //constexpr explicit variant(in_place_index_t<I>, Args&&...);
    //template<size_t I, class U, class... Args>
    //constexpr explicit variant(in_place_index_t<I>, initializer_list<U>, Args&&...);
 
    // destructor
    constexpr ~variant();
 
    // assignment
    constexpr variant& operator=(const variant&);
    //constexpr variant& operator=(variant&&) noexcept(/* see description */);
 
    //template<class T> constexpr variant& operator=(T&&) noexcept(/* see description */);
 
    // modifiers
    template<class T, class... Args> constexpr T& emplace(Args&&...);
    //template<class T, class U, class... Args>
    //constexpr T& emplace(initializer_list<U>, Args&&...);
    //template<size_t I, class... Args>
    //constexpr variant_alternative_t<I, variant<Types...>>& emplace(Args&&...);
    //template<size_t I, class U, class... Args>
    //constexpr variant_alternative_t<I, variant<Types...>>& emplace(initializer_list<U>,
    //                                                               Args&&...);
 
    // value status
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;
 
    // swap
    //constexpr void swap(variant&) noexcept(/* see description */);
 
    // visitation
    template<class Self, class Visitor>
    constexpr decltype(auto) visit(this Self&&, Visitor&&);
    template<class R, class Self, class Visitor>
    constexpr R visit(this Self&&, Visitor&&);
};

template<class T, class... Types>
constexpr bool holds_alternative(const std::variant<Types...>& v) noexcept;

//template<size_t I, class... Types>
//constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>&);
//template<size_t I, class... Types>
//constexpr variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&&);
//template<size_t I, class... Types>
//constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>&);
//template<size_t I, class... Types>
//constexpr const variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&&);
 
template<class T, class... Types>
constexpr T& get(variant<Types...>&);               // freestanding-deleted
template<class T, class... Types>
constexpr T&& get(variant<Types...>&&);             // freestanding-deleted
template<class T, class... Types>
constexpr const T& get(const variant<Types...>&);   // freestanding-deleted
template<class T, class... Types>
constexpr const T&& get(const variant<Types...>&&); // freestanding-deleted

}
