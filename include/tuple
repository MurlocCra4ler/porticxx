#pragma once

#include <bits/tuple/tuple.hpp>
#include <utility>

namespace std {

// tuple_element
template<std::size_t I, class T>
struct tuple_element;

template<std::size_t I, class Head, class... Tail>
struct tuple_element<I, std::tuple<Head, Tail...>>
    : std::tuple_element<I - 1, std::tuple<Tail...>> {};

template<class Head, class... Tail>
struct tuple_element<0, std::tuple<Head, Tail...>> {
    using type = Head;
};

template<std::size_t I, class Tuple>
using tuple_element_t = typename tuple_element<I, Tuple>::type;

// tuple_size
template<class T>
struct tuple_size;

template<class... Types>
struct tuple_size<tuple<Types...>>
    : std::integral_constant<size_t, sizeof...(Types)> {};

template<class T>
constexpr std::size_t tuple_size_v = tuple_size<T>::value;

// get
template<std::size_t I, class... Types>
constexpr auto& get(tuple<Types...>& t) {
    return static_cast<impl_tuple::tuple_leaf<I, std::tuple_element_t<I, tuple<Types...>>>&>(t).value;
}

template<class... Types>
constexpr tuple<Types&&...>
forward_as_tuple(Types&&... args) noexcept {
    return tuple<Types&&...>(forward<Types>(args)...);
}

// apply
namespace impl_tuple {

template<class F, class Tuple, size_t... Is>
constexpr decltype(auto) apply_impl(F&& f, Tuple&& t, index_sequence<Is...>) {
    return std::forward<F>(f)(std::get<Is>(std::forward<Tuple>(t))...);
}

}

template<class F, class Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t) {
    constexpr size_t N = tuple_size_v<decay_t<Tuple>>;
    return impl_tuple::apply_impl(std::forward<F>(f), std::forward<Tuple>(t), make_index_sequence<N>{});
}

}
 