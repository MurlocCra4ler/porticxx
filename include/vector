#pragma once

#include <algorithm>
#include <iterator>
#include <bits/memory/allocators.hpp>
#include <utility>

namespace std {

template<class T, class Allocator = std::allocator<T>>
class vector {
public:
    using value_type                = T;
    using allocator_type            = Allocator;
    using pointer                   = typename allocator_traits<Allocator>::pointer;
    using const_pointer             = typename allocator_traits<Allocator>::const_pointer;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using iterator                  = value_type*;
    using const_iterator            = const value_type*;
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;

    const_iterator begin() const;
    const_iterator end() const;

    const_reverse_iterator rbegin() const;
    const_reverse_iterator rend() const;

    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;

    // capacity
    constexpr bool empty() const noexcept { return m_size == 0; }
    constexpr size_type size() const noexcept { return m_size; }
    constexpr size_type max_size() const noexcept;
    constexpr size_type capacity() const noexcept { return m_capacity; }
    constexpr void resize(size_type sz);
    constexpr void resize(size_type sz, const T& c);
    constexpr void reserve(size_type n);
    constexpr void shrink_to_fit();

    // element access
    constexpr reference operator[](size_type n) { return m_data[n]; }
    constexpr const_reference operator[](size_type n) const { return m_data[n]; }
    constexpr reference front();

    // modifiers
    template<class... Args>
    constexpr reference emplace_back(Args&&... args) {
        if (m_capacity == m_size) {
            size_t new_capacity = m_capacity ? m_capacity * 2 : 1;
            T* ptr = allocator.allocate(new_capacity);

            for (size_t i = 0; i < m_size; ++i)
                new(ptr + i) T(std::move_if_noexcept(m_data[i]));

            for (size_t i = 0; i < m_size; ++i)
                m_data[i].~T();

            allocator.deallocate(m_data, m_capacity);
            
            m_data = ptr;
            m_capacity = new_capacity;
        }

        new (m_data + m_size) T(std::forward<Args>(args)...);
        ++m_size;
        return m_data[m_size - 1];
    }
    
    constexpr void push_back(const T& x) {
        if (m_capacity == m_size) {
            size_t new_capacity = m_capacity ? m_capacity * 2 : 1;
            T* ptr = allocator.allocate(new_capacity);

            for (size_t i = 0; i < m_size; ++i)
                new(ptr + i) T(std::move_if_noexcept(m_data[i]));

            for (size_t i = 0; i < m_size; ++i)
                m_data[i].~T();

            allocator.deallocate(m_data, m_capacity);
            
            m_data = ptr;
            m_capacity = new_capacity;
        }

        m_data[m_size++] = x;
    }

    constexpr void push_back(T&& x) {
        if (m_capacity == m_size) {
            size_t new_capacity = m_capacity ? m_capacity * 2 : 1;
            T* ptr = allocator.allocate(new_capacity);

            for (size_t i = 0; i < m_size; ++i)
                new(ptr + i) T(std::move_if_noexcept(m_data[i]));

            for (size_t i = 0; i < m_size; ++i)
                m_data[i].~T();

            allocator.deallocate(m_data, m_capacity);
            
            m_data = ptr;
            m_capacity = new_capacity;
        }

        m_data[m_size++] = std::move(x);
    }

    constexpr void clear() noexcept;

private:
    allocator_type allocator;

    T* m_data = nullptr;
    size_t m_size = 0;
    size_t m_capacity = 0;
};

}
