#pragma once

#include <bits/swap.hpp>
#include <type_traits>

namespace std {

/*************/
/* Functions */
/*************/

template<class T>
constexpr T&& forward(remove_reference_t<T>& t) noexcept;

template<class T>
constexpr remove_reference_t<T>&& move(T&& t) noexcept;

template<class T>
constexpr auto move_if_noexcept(T& x) noexcept
    -> conditional_t<
        is_nothrow_move_constructible_v<T> || !is_copy_constructible_v<T>,
        T&&,
        const T&>
{
    if constexpr (is_nothrow_move_constructible_v<T> ||
                    !is_copy_constructible_v<T>) {
        return static_cast<T&&>(x);
    } else {
        return static_cast<const T&>(x);
    }
}

template<class T1, class T2>
struct pair {
using first_type  = T1;
using second_type = T2;

T1 first;
T2 second;

pair(const pair&) = default;
pair(pair&&) = default;
};

/********/
/* Tags */
/********/

struct in_place_t { explicit in_place_t() = default; };

inline constexpr in_place_t in_place {};
 
template<class T>
struct in_place_type_t { explicit in_place_type_t() = default; };

template<class T>
constexpr in_place_type_t<T> in_place_type {};

template<size_t I>
struct in_place_index_t { explicit in_place_index_t() = default; };

template<size_t I>
constexpr in_place_index_t<I> in_place_index {};

template<class T, T... Ints>
class integer_sequence {};

namespace impl_utility {
template<class T, T I, T N, T... integers>
struct make_integer_sequence_helper {
    using type = typename make_integer_sequence_helper<T, I + 1, N, integers..., I>::type;
};
 
template<class T, T N, T... integers>
struct make_integer_sequence_helper<T, N, N, integers...> {
    using type = integer_sequence<T, integers...>;
};
}
 
template<class T, T N>
using make_integer_sequence = impl_utility::make_integer_sequence_helper<T, 0, N>::type;

template< std::size_t N >
using make_index_sequence = std::make_integer_sequence<std::size_t, N>;

template<size_t... Ints >
using index_sequence = integer_sequence<size_t, Ints...>;

template< class... T >
using index_sequence_for = make_index_sequence<sizeof...(T)>;

}
