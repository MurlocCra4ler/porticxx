#pragma once

#include <cstddef>
#include <exception>
#include <type_traits>
#include <utility>
#include <concepts>
#include <algorithm>
#include <new>

//#include <bits/variant/bad_variant_access.hpp>

namespace std {

template<class... Types>
class variant;

namespace impl_variant {

template<typename T> struct is_in_place_type_t : false_type {};
template<typename T> struct is_in_place_index_t : false_type {};

template<typename U>
struct is_in_place_type_t<in_place_type_t<U>> : true_type {};

template<size_t I>
struct is_in_place_index_t<in_place_index_t<I>> : true_type {};

template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
template<class... Ts> overload(Ts...) -> overload<Ts...>;

template<size_t N, typename T>
struct indexed_callable {
    constexpr T operator()(T) const;
};

template<typename... Ts, size_t... Is>
constexpr auto make_overload_impl(index_sequence<Is...>) {
    return overload{ indexed_callable<Is, Ts>{}... };
}

template<typename... Ts>
constexpr auto make_overload() {
    return make_overload_impl<Ts...>(index_sequence_for<Ts...>{});
}

template<typename T, typename... Types>
struct best_match {
    using overload_t = decltype(make_overload<Types...>());
    using type = decltype(declval<overload_t>()(declval<T>()));
};

template<typename T>
struct best_match<T> {
    using type = void;
};

template<typename T, typename... Types>
using best_match_t = typename best_match<T, Types...>::type;

template<typename T, typename First, typename... Rest>
constexpr size_t is_unique_helper() {
    if constexpr (sizeof...(Rest) == 0) {
        return is_same_v<T, First> ? 1 : 0;
    } else {
        return (is_same_v<T, First> ? 1 : 0) + is_unique_helper<T, Rest...>();
    }
}

/// Checks whether T appears exactly once in the given type pack.
template<typename T, typename... Types>
static constexpr bool is_unique() {
    return is_unique_helper<T, Types...>() == 1;
}

template<typename T, typename First, typename... Rest>
static constexpr size_t index_of_helper() {
    if constexpr (is_same_v<T, First>) {
        return 0;
    } else if constexpr (sizeof...(Rest) == 0) {
        return static_cast<size_t>(-1);  // nicht gefunden
    } else {
        constexpr size_t next = index_of_helper<T, Rest...>();
        if constexpr (next == static_cast<size_t>(-1)) {
            return static_cast<size_t>(-1);
        } else {
            return 1 + next;
        }
    }
}

/// Returns the zero-based index of T in the given type pack (requires T to be unique).
template<typename T, typename... Types>
requires(impl_variant::is_unique<T, Types...>())
static constexpr size_t index_of() {
    constexpr size_t index = index_of_helper<T, Types...>();
    static_assert(index != static_cast<size_t>(-1), "index not found");
    return index;
};

template<typename T, typename T_j, typename... Types>
concept variant_ctor_constraint =
    (sizeof...(Types) > 0) &&
    (!std::same_as<std::remove_cvref_t<T>, variant<Types...>>) &&
    (!is_in_place_type_t<std::remove_cvref_t<T>>::value) &&
    (!is_in_place_index_t<std::remove_cvref_t<T>>::value) &&
    is_constructible_v<T_j, T> &&
    requires (T&& args) {
        { make_overload<Types...>()(std::forward<T>(args)) };
    };
}

template<class... Types> class variant {
public:
    // constructors
    //constexpr variant() noexcept(/* see description */);
    constexpr variant(const variant&);
    constexpr variant(variant&&); //noexcept(/* see description */);
 
    template<class T, typename T_j = impl_variant::best_match_t<T, Types...>>
    requires impl_variant::variant_ctor_constraint<T, T_j, Types...>
    constexpr variant(T&& args) noexcept(std::is_nothrow_constructible_v<impl_variant::best_match_t<remove_cvref_t<T>>, T>) {
        m_index = impl_variant::index_of<T_j, Types...>();
        new (&m_storage) T_j(std::forward<T>(args));
    }
 
    //template<class T, class... Args>
    //constexpr explicit variant(in_place_type_t<T>, Args&&...);
    //template<class T, class U, class... Args>
    //constexpr explicit variant(in_place_type_t<T>, initializer_list<U>, Args&&...);
 
    //template<size_t I, class... Args>
    //constexpr explicit variant(in_place_index_t<I>, Args&&...);
    //template<size_t I, class U, class... Args>
    //constexpr explicit variant(in_place_index_t<I>, initializer_list<U>, Args&&...);
 
    // destructor
    constexpr ~variant() {
        using dtor_func_t = void(*)(void*);
        static constexpr dtor_func_t destructors[] = { 
            [](void* p){ reinterpret_cast<Types*>(p)->~Types(); }...
        };

        if (m_index == -1) return;
        destructors[m_index](&m_storage);
    }
 
    // assignment
    constexpr variant& operator=(const variant&);
    constexpr variant& operator=(variant&&); // noexcept(/* see description */);
 
    template<class T> constexpr variant& operator=(T&&); //noexcept(/* see description */);
 
    // modifiers
    template<class T, class... Args> constexpr T& emplace(Args&&...);
    //template<class T, class U, class... Args>
    //constexpr T& emplace(initializer_list<U>, Args&&...);
    //template<size_t I, class... Args>
    //constexpr variant_alternative_t<I, variant<Types...>>& emplace(Args&&...);
    //template<size_t I, class U, class... Args>
    //constexpr variant_alternative_t<I, variant<Types...>>& emplace(initializer_list<U>,
    //                                                               Args&&...);
 
    // value status
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept { return m_index; }
 
    // swap
    //constexpr void swap(variant&) noexcept(/* see description */);
 
    // visitation
    template<class Self, class Visitor>
    constexpr decltype(auto) visit(this Self&&, Visitor&&);
    template<class R, class Self, class Visitor>
    constexpr R visit(this Self&&, Visitor&&);

private:
    static constexpr size_t max_size = max({sizeof(Types)...});
    static constexpr size_t max_align = max({alignof(Types)...});

    static constexpr size_t alignment_value = max_align;

    alignas(alignment_value) char m_storage[max_size];
    size_t m_index;

    template<typename T, typename... Ts>
    friend constexpr const T& get(const std::variant<Ts...>&);
};

template<class T, class... Types>
constexpr bool holds_alternative(const variant<Types...>& v) noexcept {
    constexpr size_t index = impl_variant::index_of<T, Types...>();
    return index == v.index();
}

//template<size_t I, class... Types>
//constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>&);
//template<size_t I, class... Types>
//constexpr variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&&);
//template<size_t I, class... Types>
//constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>&);
//template<size_t I, class... Types>
//constexpr const variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&&);

template<typename T, typename... Types>
constexpr T& get(variant<Types...>& v) {
    //constexpr size_t index = impl_variant::index_of<T, Types...>();
    //if (other.active_index != index) return std::make_exception_ptr(bad_variant_access());
    return *reinterpret_cast<T*>(v.m_storage);
}

template<typename T, typename... Types>
constexpr T&& get(std::variant<Types...>&& v) {
    return std::move(*reinterpret_cast<T*>(v.m_storage));
}

template<typename T, typename... Types>
constexpr const T& get(const std::variant<Types...>& v) {
    //constexpr size_t index = impl_variant::index_of<T, Types...>();
    //if (other.active_index != index) return std::make_exception_ptr(bad_variant_access());
    return *reinterpret_cast<const T*>(v.m_storage);
}

template<typename T, typename... Types>
constexpr const T&& get(const std::variant<Types...>&& v) {
    return std::move(*reinterpret_cast<T const*>(v.m_storage));
}

}
