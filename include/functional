#pragma once

#include <memory>
#include <type_traits>
#include <utility>

namespace std {

template<class> class function;

template<typename T>
typename std::add_rvalue_reference<T>::type declval() noexcept {
    static_assert(false, "declval not allowed in an evaluated context");
}

template< class F, class... Args >
std::invoke_result_t<F, Args...>
    invoke(F&& f, Args&&... args) noexcept;

template<class R, class F, class... Args>
constexpr R
    invoke_r( F&& f, Args&&... args ) noexcept;

namespace impl_functional {
    template<class T> constexpr T& FUN(T& t) noexcept { return t; }
    template<class T> void FUN(T&&) = delete;
}
 
template<class T>
class reference_wrapper {
public:
    // types
    using type = T;
 
    // construct/copy/destroy
    template<class U, class = decltype(
        impl_functional::FUN<T>(std::declval<U>()),
        std::enable_if_t<!std::is_same_v<reference_wrapper, std::remove_cvref_t<U>>>()
    )>
    constexpr reference_wrapper(U&& u)
        noexcept(noexcept(impl_functional::FUN<T>(std::forward<U>(u))))
        : _ptr(std::addressof(impl_functional::FUN<T>(std::forward<U>(u)))) {}
 
    reference_wrapper(const reference_wrapper&) noexcept = default;
 
    // assignment
    reference_wrapper& operator=(const reference_wrapper& x) noexcept = default;
 
    // access
    constexpr operator T& () const noexcept { return *_ptr; }
    constexpr T& get() const noexcept { return *_ptr; }
 
    /*
    template<class... ArgTypes>
    constexpr std::invoke_result_t<T&, ArgTypes...>
        operator() (ArgTypes&&... args ) const
            noexcept(std::is_nothrow_invocable_v<T&, ArgTypes...>)
    {
        return std::invoke(get(), std::forward<ArgTypes>(args)...);
    }*/
 
private:
    T* _ptr;
};
 
// deduction guides
template<class T>
reference_wrapper(T&) -> reference_wrapper<T>;

}
