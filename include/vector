#pragma once

#include <algorithm>
#include <iterator>
#include <bits/memory/allocators.hpp>
#include <utility>

namespace std {

template<class T, class Allocator = std::allocator<T>>
class vector {
public:
    using value_type                = T;
    using allocator_type            = Allocator;
    using pointer                   = typename allocator_traits<Allocator>::pointer;
    using const_pointer             = typename allocator_traits<Allocator>::const_pointer;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using iterator                  = value_type*;
    using const_iterator            = const value_type*;
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;

    // construct/copy/destroy
    constexpr vector() noexcept(noexcept(Allocator())) : vector(Allocator()) {}
    constexpr explicit vector(const Allocator& alloc) noexcept : alloc_(alloc) {}
    constexpr explicit vector(size_type n, const Allocator& = Allocator());
    constexpr vector(size_type n, const T& value, const Allocator& = Allocator());
    template<class InputIter>
    constexpr vector(InputIter first, InputIter last, const Allocator& = Allocator());
    //template<container-compatible-range<T> R>
    //constexpr vector(from_range_t, R&& rg, const Allocator& = Allocator());
    constexpr vector(const vector& other) : alloc_(other.alloc_) {
        reserve(other.size());
        for (const auto& el : other) {
            push_back(el);
        }
    }
    constexpr vector(vector&& other) noexcept : alloc_(std::move(other.alloc_)), data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }
    //constexpr vector(const vector&, const type_identity_t<Allocator>&);
    //constexpr vector(vector&&, const type_identity_t<Allocator>&);
    constexpr vector(initializer_list<T> init, const Allocator& alloc = Allocator()) : alloc_(alloc) {
        reserve(init.size());
        for (const auto& el : init) {
            push_back(el);
        }
    }
    constexpr ~vector() {
        if (capacity_ > 0) {
            alloc_.deallocate(data_, capacity_);
        }
    }

    constexpr iterator begin() noexcept { return data_; }
    constexpr const_iterator begin() const noexcept { return data_; }
    constexpr iterator end() noexcept { return data_ + size_; }
    constexpr const_iterator end() const noexcept { return data_ + size_; }
    constexpr reverse_iterator rbegin() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator rend() noexcept;
    constexpr const_reverse_iterator rend() const noexcept;
 
    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;

    // capacity
    constexpr bool empty() const noexcept { return size_ == 0; }
    constexpr size_type size() const noexcept { return size_; }
    constexpr size_type max_size() const noexcept;
    constexpr size_type capacity() const noexcept { return capacity_; }
    constexpr void resize(size_type sz);
    constexpr void resize(size_type sz, const T& c);
    constexpr void reserve(size_type n) {
        if (n <= capacity_) return;

        T* ptr = alloc_.allocate(n);

        for (size_t i = 0; i < size_; ++i)
            new(ptr + i) T(std::move_if_noexcept(data_[i]));

        for (size_t i = 0; i < size_; ++i)
            data_[i].~T();

        alloc_.deallocate(data_, capacity_);
        
        data_ = ptr;
        capacity_ = n;
    }
    constexpr void shrink_to_fit();

    // element access
    constexpr reference operator[](size_type n) { return data_[n]; }
    constexpr const_reference operator[](size_type n) const { return data_[n]; }
    constexpr reference front();

    // data access
    constexpr T* data() noexcept { return data_; }
    constexpr const T* data() const noexcept { return data_; }

    // modifiers
    template<class... Args>
    constexpr reference emplace_back(Args&&... args) {
        if (capacity_ <= size_) reserve(capacity_ ? capacity_ * 2 : 1);

        new (data_ + size_) T(std::forward<Args>(args)...);
        ++size_;
        return data_[size_ - 1];
    }
    
    constexpr void push_back(const T& x) {
        if (capacity_ <= size_) reserve(capacity_ ? capacity_ * 2 : 1);

        data_[size_++] = x;
    }

    constexpr void push_back(T&& x) {
        if (capacity_ == size_) {
            size_t new_capacity = capacity_ ? capacity_ * 2 : 1;
            T* ptr = alloc_.allocate(new_capacity);

            for (size_t i = 0; i < size_; ++i)
                new(ptr + i) T(std::move_if_noexcept(data_[i]));

            for (size_t i = 0; i < size_; ++i)
                data_[i].~T();

            alloc_.deallocate(data_, capacity_);
            
            data_ = ptr;
            capacity_ = new_capacity;
        }

        data_[size_++] = std::move(x);
    }

    constexpr void clear() noexcept;

private:
    allocator_type alloc_;

    T* data_ = nullptr;
    size_t size_ = 0;
    size_t capacity_ = 0;
};

}
