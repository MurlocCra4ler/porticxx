#pragma once

#include <cstdlib>
#include <functional>
#include <variant>

#define NOEXCEPT noexcept

namespace std {

class exception {
public:
    virtual const char* what() const noexcept;
};

class exception_ptr : public std::shared_ptr<exception> {
public:
    using std::shared_ptr<exception>::shared_ptr;
    using std::shared_ptr<exception>::operator bool;

    void abort() const;
};

template<class E>
std::exception_ptr make_exception_ptr(E e) noexcept;

template<typename T>
class result_ref;

template<typename T>
class result {
public:
    result(const T& v) : data(v) {}
    result(T&& v) : data(std::move(v)) {}
    result(const std::exception_ptr& e) : data(e) {}

    bool ok() const noexcept {
        return std::holds_alternative<T>(data);
    }

    constexpr operator const T&() const {
        if (!ok()) std::get<std::exception_ptr>(data).abort();
        return std::get<T>(data);
    }

    template<typename U>
    T value_or(U&& alt) const {
        return ok() ? std::get<T>(data) : alt;
    }

    template<typename U>
    result<U> map_to(const U& alt) const {
        if (ok()) return alt;
        else return std::get<std::exception_ptr>(data);
    }

    template<typename U>
    result_ref<U> map_to_ref(const U& alt) const {
        if (ok()) return alt;
        else return std::get<std::exception_ptr>(data);
    }

protected:
    std::variant<T, std::exception_ptr> data;
};

template <>
class result<void> {
public:
    result() = default;
    result(std::exception_ptr e) : error(e) {}

    constexpr bool ok() const noexcept { return !error; }

    template<typename U>
    result<U> map_to(const U& alt) const {
        if (ok()) return alt;
        else return error;
    }

    template<typename U>
    result_ref<U> map_to_ref(U& alt) const {
        if (ok()) return alt;
        else return error;
    }

protected:
    exception_ptr error;
};

template<typename T>
class result_ref : public result<std::reference_wrapper<T>> {
public:
    result_ref(T& v) : result<std::reference_wrapper<T>>(v) {}
    //result_ref(const T& v) : result<std::reference_wrapper<const T>>(std::cref(v)) {}
    //result_ref(const std::reference_wrapper<T>& v) : result<std::reference_wrapper<T>>(v) {}
    result_ref(const std::exception_ptr& e) : result<std::reference_wrapper<T>>(e) {}

    constexpr operator T&() const {
        if (!this->ok()) get<std::exception_ptr>(this->data).abort();
        return get<std::reference_wrapper<T>>(this->data);
    } 
};

}
