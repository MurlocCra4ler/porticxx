#pragma once

#include <bits/iterator/primitives.hpp>
#include <bits/algorithm/sorting_operations.hpp>
#include <initializer_list>

namespace std {

// find
template<class InputIt, class T = typename std::iterator_traits<InputIt>::value_type>
constexpr InputIt find(InputIt first, InputIt last, const T& value) {
    for (; first != last; ++first) {
        if (*first == value) {
            return first;
        }   
    }

    return last;
}

template<class InputIt, class UnaryPred>
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPred p) {
    for (; first != last; ++first) {
        if (p(*first)) {
            return first;
        }
    }

    return last;
}

// merge
template<class InputIter1, class InputIter2, class OutputIter>
constexpr OutputIter merge(InputIter1 first1, InputIter1 last1,
                            InputIter2 first2, InputIter2 last2, OutputIter result);

// set_interscect
template< class InputIt1, class InputIt2, class OutputIt >
OutputIt set_intersection( InputIt1 first1, InputIt1 last1,
                           InputIt2 first2, InputIt2 last2,
                           OutputIt d_first );

template<class ForwardIt>
constexpr ForwardIt max_element(ForwardIt first, ForwardIt last) {
    if (first == last)
        return last;
 
    ForwardIt largest = first;
 
    while (++first != last)
        if (*largest < *first)
            largest = first;
 
    return largest;
}

template<class T>
constexpr const T& max(const T& a, const T& b) {
    return a >= b ? a : b;
}

template<class T>
constexpr T max(initializer_list<T> il) {
    return *max_element(il.begin(), il.end());
}

template<class T>
constexpr const T& min(const T& a, const T& b) {
    return a <= b ? a : b;
}

}
