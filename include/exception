#pragma once

#include <cstdlib>
#include <exception>
#include <functional>
#include <memory>
#include <type_traits>
#include <variant>

#define NOEXCEPT noexcept

namespace std {

class exception {
public:
    virtual const char* what() const noexcept;
};

class exception_ptr {
public:
    exception_ptr() = default;
    exception_ptr(const shared_ptr<exception>& ptr) : m_ptr(ptr) {} 
    
    explicit operator bool() const noexcept {
        return static_cast<bool>(m_ptr);
    }

    void abort() const;

private:
    std::shared_ptr<exception> m_ptr;
};

template<class E>
constexpr exception_ptr make_exception_ptr(E e) noexcept {
    static_assert(is_base_of_v<std::exception, E>, "E must derive from std::exception");
    return exception_ptr(std::make_shared<exception>(std::move(e)));
}

template<typename T>
class result_ref;

template<typename T>
class result {
public:
    result(const T& v) : data(v) {}
    //result(T&& v) data(std::move(v)) {}
    result(const std::exception_ptr& e) : data(e) {}

    result (const result&) = delete;
    result& operator= (const result&) = delete;

    bool ok() const noexcept {
        return std::holds_alternative<T>(data);
    }

    constexpr operator T&() {
        if (!ok()) std::get<std::exception_ptr>(data).abort();
        return std::get<T>(data);
    }

    constexpr operator const T&() const {
        if (!ok()) std::get<std::exception_ptr>(data).abort();
        return std::get<T>(data);
    }

    template<typename U>
    T value_or(U&& alt) const {
        return ok() ? std::get<T>(data) : alt;
    }

    template<typename U>
    result<U> map_to(const U& alt) const {
        if (ok()) return alt;
        else return std::get<std::exception_ptr>(data);
    }

    template<typename U>
    result_ref<U> map_to_ref(const U& alt) const {
        //if (ok()) return alt;
        //else return std::get<std::exception_ptr>(data);
    }

protected:
    std::variant<T, std::exception_ptr> data;
};

template <>
class result<void> {
public:
    result() = default;
    result(std::exception_ptr e) : error(e) {}

    constexpr bool ok() const noexcept { return !error; }

    template<typename U>
    result<U> map_to(const U& alt) const {
        //if (ok()) return alt;
        //else return error;
    }

    template<typename U>
    result_ref<U> map_to_ref(U& alt) const {
        if (ok()) return alt;
        else return error;
    }

protected:
    exception_ptr error;
};

template<typename T>
class result_ref : public result<std::reference_wrapper<T>> {
public:
    result_ref(T& v) : result<std::reference_wrapper<T>>(v) {}
    //result_ref(const T& v) : result<std::reference_wrapper<const T>>(std::cref(v)) {}
    //result_ref(const std::reference_wrapper<T>& v) : result<std::reference_wrapper<T>>(v) {}
    result_ref(const std::exception_ptr& e) : result<std::reference_wrapper<T>>(e) {}

    constexpr operator T&() const {
        if (!this->ok()) get<std::exception_ptr>(this->data).abort();
        return get<std::reference_wrapper<T>>(this->data);
    }
};

}
